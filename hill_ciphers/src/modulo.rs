extern crate nalgebra as na;
use crate::matrix::CipherMatrix2;
use na::DMatrix;
use prime_factorization::Factorization;
use std::collections::HashSet;

trait RemoveDuplicates<T> {
    fn remove_duplicates(&self) -> Vec<T>;
}

// TODO: is there a better way to do this?
impl<T: Eq + std::hash::Hash + Clone> RemoveDuplicates<T> for Vec<T> {
    fn remove_duplicates(&self) -> Vec<T> {
        self.iter()
            .collect::<HashSet<&T>>() // collect into a HashSet to remove duplicates
            .into_iter() // convert HashSet back into an Iterator
            .cloned() // clone the items to move from &T to T
            .collect() // collect into Vec<T>
    }
}

// https://en.wikipedia.org/wiki/Euler%27s_totient_function
fn euler_totient(n: u64) -> u64 {
    let prime_factorization = Factorization::run(n);

    let mut result = n as f64;

    for factor in prime_factorization.factors.remove_duplicates() {
        result *= 1.0 - (1.0 / factor as f64);
    }

    result as u64
}

// function generated by ChatGPT4 to optimize modular exponentiation
fn modular_exponentiation(base: i32, exponent: i32, modulus: i32) -> i32 {
    // convert to u64 to handle negative values
    let mut base = base as u32;
    let mut exponent = exponent as u32;
    let modulus = modulus as u32;
    let mut result = 1u32;

    // ensure the base is within the modulus to start
    base = base % modulus;

    while exponent > 0 {
        // if the exponent is odd, multiply the current base with the result
        if exponent % 2 == 1 {
            result = (result * base) % modulus;
        }
        // square the base
        base = (base * base) % modulus;
        // divide the exponent by 2
        exponent >>= 1;
    }

    // convert the result back to i64
    result as i32
}

// https://en.wikipedia.org/wiki/Euler%27s_theorem
pub fn modular_inverse(n: i32, modulus: i32) -> i32 {
    modular_exponentiation(n, euler_totient(modulus as u64) as i32 - 1, modulus)
}

pub fn matrix_modular_inverse(matrix: &CipherMatrix2, modulus: i32) -> CipherMatrix2 {
    let a = &matrix.matrix;

    let det = a[(0, 0)] * a[(1, 1)] - a[(0, 1)] * a[(1, 0)];

    let det_inv = modular_inverse(det, modulus);

    let adj = CipherMatrix2::new(a[(1, 1)], -a[(0, 1)], -a[(1, 0)], a[(0, 0)]);

    adj.scale(det_inv).modulo(modulus)
}

pub fn matrix_modulo(matrix: &DMatrix<i32>, modulus: i32) -> DMatrix<i32> {
    matrix.map(|elem| {
        let mut a = elem % modulus;
        // ensure the result is non-negative
        if a < 0 {
            a += modulus;
        }
        a
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_euler_totient() {
        assert_eq!(euler_totient(26), 12);
        assert_eq!(euler_totient(29), 28);
    }

    #[test]
    fn test_modular_inverse() {
        assert_eq!(modular_inverse(7, 26), 15);
        assert_eq!(modular_inverse(3, 25), 17);
        assert_eq!(modular_inverse(24, 29), 23);
    }

    #[test]
    fn test_modulo_matrix_inverse() {}
}
